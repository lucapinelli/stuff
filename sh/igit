#!/usr/bin/env bash

set -e # exit if a commands returns a non-zero value

blue="\033[00;34m"
red="\033[00;31m"
reset="\033[00m"

error() {
  echo -e "${red}[error] $1${reset}";
}

info() {
  echo -e "${blue}[info] $1${reset}";
}

HELP="

USAGE:

  igit <ACTION> [OPTIONS]

ACTIONS:

  status
    shows the git status, the stash list and the unmerged branches

  pull
    pull the changes, shows the git status, the stash list and the unmerged branches

  push <message>
    pull, commit and push

  log [search pattern]
    if text-filter is not specified logs the lasts 60 commits,
    otherwise show all the commits that matches the given pattern

  diff [git diff options]
    shows the diffs using Meld

  mr <new commit/branch name>
    commits and pushes the staged changes to a new branch

  stash <staged|unstaged> <stash name>
    stashes the staged or the unstaged changes

  checkout <branch name>
    stashes the local changes, checkouts the branch, updates it and pop the stash

  restore <file/directory>
    restore the specified file/directory to the original content

  apply <file.patch>
    applies the specified patch

  list <type> [-1]
    <type> list file that has been:
            ?, untracked
            A, added
            M, modified
            D, deleted
    -1      list one file per line

  help
    show this help
"

help () {
  echo "$HELP"
}

wrong_syntax () {
  error "wrong syntax"
  help
  exit 1
}

status() {
  (
    set -x # print each command before executing it
    git status -sb
    git cherry -v # lists local commits that require a push
    git stash list
    git branch
  )
}

pull() {
  info "git pull"
  git pull
  status
  info "git fetch --dry-run --prune # list removed branches"
  removed=$(git fetch --dry-run --prune 2>&1)
  if [ -n "${removed}" ]; then
    info "Removed branches:\n${removed}"
    read -p "Clean up removed branches? (y/n, default n) " yn
    if [ "$yn" = "y" ]; then
      info 'git fetch --prune'
      git fetch --prune
    fi
  fi
}

push() {
  if [ -z "$1" ]; then # if $1 is empty
    error "you need to specify the commit message"
    exit 1
  fi
  (
    set -x # print each command before executing it
    git pull
    git commit -m "$1"
    git push
    git status
  )
}

log() {
  if [ -z "$1" ]; then # if $1 is empty
    info "git log --format='%ad %h %aE %s' --date='format:%Y.%m.%d %H:%M' --max-count=60 | grep -v 'Merge' | tac"
    git log --format='%ad %h %aE %s' --date='format:%Y.%m.%d %H:%M' --max-count=60 | grep -v 'Merge' | tac
  else
    info "git log --format='%ad %h %aE %s' --date='format:%Y.%m.%d %H:%M'  | grep -e \"$1\" | grep -v 'Merge' | tac"
    git log --format='%ad %h %aE %s' --date='format:%Y.%m.%d %H:%M'  | grep -e "$1" | grep -v 'Merge' | tac
  fi
}

diff() {
  (
    set -x # print each command before executing it
    git difftool --tool=meld --dir-diff $@;
  )
}

mr() {
  # if $1 is empty print the help and exit
  if [ -z "$1" ]; then wrong_syntax; fi

  commit="$1"
  branch="$(echo $1 | sd ' ' '-')"

  (
    set -x # print each command before executing it
    git checkout -b $branch && \
    git commit -m "$commit" && \
    git push --set-upstream origin $branch;
  )
}

stash_unstaged() {
  # if $1 is empty print the help and exit
  if [ -z "$1" ]; then
    error "you need to specify the stash name: igit stash unstaged '<stash name>'"
    exit 2
  fi

  (
    set -x # print each command before executing it
    git commit -m 'temp' && \
    git stash save "$1" && \
    git reset HEAD^1 && \
    git add .
  )
}

stash_staged() {
  # if $1 is empty print the help and exit
  if [ -z "$1" ]; then
    error "you need to specify the stash name: igit stash staged '<stash name>'"
    exit 2
  fi

  (
    set -x # print each command before executing it
    git commit -m 'staged'
    git stash save "unstaged"
    git reset HEAD^1
    git add .
    git stash save "$1" # <stash name>
    git stash list | rg '^stash@\{1\}.*unstaged$' # verify that stash@{1} is the "unstaged"
    git stash pop stash@{1} # pop 'unstaged'
  )
}

stash() {
  # if $1 is empty print the help and exit
  if [ -z "$1" ]; then
    error "you need to specify the stash name: igit stash staged '<stash name>'"
    exit 2
  fi

  case "$1" in
    "staged")
      stash_staged "$2" ;;
    "unstaged")
      stash_unstaged "$2" ;;
    *)
      error "you need to specify if you want to stash the staged or the unstaged"
      exit 2
      ;;
  esac
}

checkout() {
  # if $1 is empty print the help and exit
  if [ -z "$1" ]; then wrong_syntax; fi

  branchName="$1"
  (
    set -x # print each command before executing it
    git stash
    git checkout "$branchName"
    git pull
    git stash pop
  )
}

restore() {
  # if $1 is empty print the help and exit
  if [ -z "$1" ]; then wrong_syntax; fi

  paths="$@"
  (
    set -x # print each command before executing it
    git reset HEAD $paths
    git add $paths
    git reset HEAD $paths
    git checkout $paths
  )
}

apply() {
  # if $1 is empty print the help and exit
  if [ -z "$1" ]; then wrong_syntax; fi

  patch_file="$1"
  (
    set -x # print each command before executing it
    git apply --3way --ignore-space-change --ignore-whitespace "$patch_file"
  )
}

list() {
  # if $1 is empty print the help and exit
  if [ -z "$1" ]; then wrong_syntax; fi

  case "$1" in
    "untracked" | "?")
      if [ "$2" = "-1" ]; then
        git status -sb | grep '^[?][?] ' | sed -r 's/.. "?([^"]*)"?/"\1"/g'
      else
        git status -sb | grep '^[?][?] ' | sed -r 's/.. "?([^"]*)"?/"\1"/g' | tr '\n' ' '
        echo ""
      fi
      ;;

    "added" | "A")
      if [ "$2" = "-1" ]; then
        git status -sb | grep '^A  ' | sed -r 's/.. (.*)/\1/g'
      else
        git status -sb | grep '^A  ' | sed -r 's/.. (.*)/\1/g' | tr '\n' ' '
        echo ""
      fi
      ;;

    "modified" | "M")
      if [ "$2" = "-1" ]; then
        git status -sb | grep '^ M ' | sed -r 's/.. (.*)/\1/g'
      else
        git status -sb | grep '^ M ' | sed -r 's/.. (.*)/\1/g' | tr '\n' ' '
        echo ""
      fi
      ;;

    "deleted" | "D")
      if [ "$2" = "-1" ]; then
        git status -sb | grep '^ D ' | sed -r 's/.. (.*)/\1/g'
      else
        git status -sb | grep '^ D ' | sed -r 's/.. (.*)/\1/g' | tr '\n' ' '
        echo ""
      fi
      ;;
    *)
      wrong_syntax
      ;;
  esac
}

case "$1" in
  "status")
    status ;;
  "pull")
    pull ;;
  "push")
    push "$2" ;;
  "log")
    log "$2" ;;
  "diff")
    diff ${@:2} ;;
  "mr")
    mr "$2" ;;
  "stash")
    stash "$2" "$3" ;;
  "stash_unstaged")
    stash_unstaged "$2" ;;
  "checkout")
    checkout "$2" ;;
  "restore")
    restore ${@:2} ;;
  "apply")
    apply "$2" ;;
  "list")
    list "$2" "$3" ;;
  "h"|"-h"|"help"|"--help")
    help ;;
  *)
    wrong_syntax ;;
esac
